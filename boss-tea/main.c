#include <stdio.h>

#define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))

char S[256];
char key[] = "HATSISTHEBEST";
unsigned char correct[44][16] = {{0x9b,0xc5,0x83,0x81,0x68,0xe8,0x9e,0x46,0x7d,0x5c,0xec,0xb,0x62,0xb2,0xca,0x69},{0x37,0x11,0x8a,0x7e,0xdd,0x6d,0x48,0xbf,0x33,0xe6,0xe2,0x2e,0xdc,0xac,0x48,0x94},{0x35,0x92,0x60,0xf9,0xf0,0xc,0xfe,0x47,0x70,0x67,0xc6,0xcb,0x8f,0xe5,0x29,0x8c},{0x16,0x5,0x20,0x1e,0xa,0x5d,0x19,0x1,0x6e,0xc,0xd1,0xf7,0xa6,0x6e,0xc6,0xdc},{0x11,0xdf,0xd1,0xf0,0xac,0x1a,0x1a,0xb8,0xe5,0xd0,0x16,0xd3,0xe,0x3b,0xe9,0x6d},{0xc4,0xc0,0x38,0xd5,0xa6,0xbc,0xb,0x7d,0xd4,0x5c,0x7,0x23,0x65,0xb1,0x73,0x45},{0xc8,0x5c,0xb5,0xaa,0xf3,0xd9,0x48,0xb6,0x32,0xb3,0x74,0xa9,0xe3,0x33,0x2b,0x4a},{0x1c,0xec,0x5c,0xf7,0xa8,0xed,0x43,0xf0,0xc2,0x82,0xa0,0x40,0x7b,0xac,0x1e,0x70},{0xc1,0xa2,0x48,0x74,0xd1,0xd0,0x89,0x42,0xe7,0x2f,0xd,0x3c,0xc1,0x9c,0xf2,0x5b},{0xc6,0x97,0xa6,0x8a,0x80,0x1c,0x7c,0xb9,0x73,0x80,0xe8,0xf9,0x9e,0x9d,0x5,0x9f},{0xf,0x22,0xc6,0xa6,0xc0,0xe4,0x98,0x8a,0xf6,0x1b,0x28,0x40,0x1b,0x13,0xc4,0xce},{0xa2,0x64,0x32,0x1c,0xd5,0x5c,0xbb,0xf5,0xa8,0x43,0x57,0x8d,0xfc,0x84,0x28,0x32},{0xfe,0x13,0x2,0x7,0x66,0xe4,0xe1,0x4a,0x38,0xf9,0x8c,0x5a,0xe6,0xfc,0x9e,0x38},{0xbc,0xdd,0x1b,0x18,0x66,0x33,0x39,0x45,0x9c,0x19,0xc9,0x47,0x94,0x74,0x8a,0xca},{0x43,0x49,0x12,0x44,0xd,0xf1,0x42,0xe,0x60,0x56,0x58,0xcf,0x50,0x8a,0xd8,0xb5},{0xd1,0x5f,0x4f,0x43,0xdb,0x13,0xf8,0xe5,0xf0,0xb3,0xfc,0x7b,0xaa,0x31,0x37,0x46},{0x66,0x26,0x2d,0xa1,0x3d,0xb6,0xfc,0x9,0xc4,0x9b,0x3,0x4d,0x7a,0x97,0x41,0x27},{0xeb,0xcf,0xe8,0xae,0x34,0x0,0x6f,0x91,0xf5,0x21,0x8d,0xff,0xd3,0xb5,0x87,0x80},{0xff,0xd3,0x63,0x11,0x5e,0xea,0xb2,0xbc,0xb2,0x25,0x7a,0x22,0x78,0x50,0x53,0x1},{0x80,0x18,0xd2,0x30,0x9b,0x78,0x98,0x9a,0xdf,0x54,0xce,0xb1,0x93,0x85,0x50,0xcc},{0xdd,0x65,0xe8,0xfc,0xdc,0xfc,0x40,0xf8,0x18,0x9f,0x24,0xd,0xdd,0x8d,0x37,0x8c},{0x76,0xb3,0xb5,0xe6,0x21,0xe,0xf7,0xc6,0x39,0x78,0xa6,0x85,0xf5,0x9b,0x3e,0x9a},{0xf9,0xab,0x97,0x4c,0xb9,0xe9,0x62,0xcf,0x34,0x33,0x62,0x0,0xb6,0x57,0x4d,0xd6}};
unsigned char prga_i = 0, prga_j = 0;

void ksa() {
    for (int i = 0; i < 256; ++i) {
        S[i] = i;
    }
    unsigned char j = 0;
    for (int i = 0; i < 256; ++i) {
        j += S[i] + key[i % sizeof(key)];
        char tmp = S[i];
        S[i] = S[j];
        S[j] = tmp;
    }
}

char prga() {
    prga_i++; prga_j++;
    char tmp = S[prga_i];
    S[prga_i] = S[prga_j];
    S[prga_j] = tmp;
    return S[prga_i] + S[prga_j];
}

void encrypt (unsigned int v[2], unsigned int k[4]) {
    unsigned int v0=v[0], v1=v[1], sum=0, i;           /* set up */
    unsigned int delta=0x9E3779B9;                     /* a key schedule constant */
    unsigned int k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */
    for (i=0; i<32; i++) {                         /* basic cycle start */
        sum += delta;
        v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
        v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);
    }                                              /* end cycle */
    v[0]=v0; v[1]=v1;
}

void md5(unsigned char *initial_msg, size_t initial_len, unsigned int out[4]) {
 
    // Message (to prepare)
    unsigned char *msg = NULL;
 
    // Note: All variables are unsigned 32 bit and wrap modulo 2^32 when calculating
 
    // r specifies the per-round shift amounts
 
    unsigned int r[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
                    5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
                    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
                    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};

    // Use binary integer part of the sines of integers (in radians) as constants// Initialize variables:
    unsigned int k[] = {
        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
        0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
        0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
        0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
        0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
        0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
        0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
        0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};
 
    unsigned int h0 = 0x67452301;
    unsigned int h1 = 0xefcdab89;
    unsigned int h2 = 0x98badcfe;
    unsigned int h3 = 0x10325476;
 
    // Pre-processing: adding a single 1 bit
    //append "1" bit to message    
    /* Notice: the input bytes are considered as bits strings,
       where the first bit is the most significant bit of the byte.[37] */
 
    // Pre-processing: padding with zeros
    //append "0" bit until message length in bit ≡ 448 (mod 512)
    //append length mod (2 pow 64) to message
 
    int new_len = ((((initial_len + 8) / 64) + 1) * 64) - 8;
 
    msg = calloc(new_len + 64, 1); // also appends "0" bits 
                                   // (we alloc also 64 extra bytes...)
    memcpy(msg, initial_msg, initial_len);
    msg[initial_len] = 128; // write the "1" bit
 
    unsigned int bits_len = 8*initial_len; // note, we append the len
    memcpy(msg + new_len, &bits_len, 4);           // in bits at the end of the buffer
 
    // Process the message in successive 512-bit chunks:
    //for each 512-bit chunk of message:
    int offset;
    for(offset=0; offset<new_len; offset += (512/8)) {
 
        // break chunk into sixteen 32-bit words w[j], 0 ≤ j ≤ 15
        unsigned int *w = (unsigned int *) (msg + offset);
 
        // Initialize hash value for this chunk:
        unsigned int a = h0;
        unsigned int b = h1;
        unsigned int c = h2;
        unsigned int d = h3;
 
        // Main loop:
        unsigned int i;
        for(i = 0; i<64; i++) { 
            unsigned int f, g;
 
             if (i < 16) {
                f = (b & c) | ((~b) & d);
                g = i;
            } else if (i < 32) {
                f = (d & b) | ((~d) & c);
                g = (5*i + 1) % 16;
            } else if (i < 48) {
                f = b ^ c ^ d;
                g = (3*i + 5) % 16;          
            } else {
                f = c ^ (b | (~d));
                g = (7*i) % 16;
            }

            unsigned int temp = d;
            d = c;
            c = b;
            b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);
            a = temp;
        }
 
        // Add this chunk's hash to result so far:
 
        h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;
    }

    out[0] = h0;
    out[1] = h1;
    out[2] = h2;
    out[3] = h3;
 
    // cleanup
    free(msg);
}

char blah(char c, char out[16]) {
    c *= 67;
    c *= 11;
    c += 33;
    
    unsigned int v[2];
    v[0] = (c << 6) + (prga() << 4) + (prga() << 2) + prga();
    v[1] = (prga() << 6) + (prga() << 4) + (prga() << 2) + c;

    unsigned int k[4];
    k[0] = (prga() << 6) + (prga() << 4) + (prga() << 2) + prga();
    k[1] = (prga() << 6) + (prga() << 4) + (prga() << 2) + prga();
    k[2] = (prga() << 6) + (prga() << 4) + (prga() << 2) + prga();
    k[3] = (prga() << 6) + (prga() << 4) + (prga() << 2) + prga();

    encrypt(v, k);

    unsigned int o[4];
    md5((char*) v, 8, o);

    memcpy(out, o, 16);
}

int main() {
    ksa();

    printf("Enter the flag and I will tell you if it is correct: ");
    char input[256];
    scanf("%255s", input);

    if (strlen(input) != 23) {
        puts("WRONG");
        return 0;
    }
    
    // printf("{");
    for (int i = 0; i < strlen(input); ++i) {
        char hash[16];
        blah(input[i], hash);

        // if (i > 0) printf(",");
        // printf("{");
        // for (int j = 0; j < 16; ++j) {
        //     if (j > 0) printf(",");
        //     printf("0x%hhx", hash[j]);
        // }
        // printf("}");
        if (memcmp(hash, correct[i], 16) != 0) {
            puts("WRONG");
            return 0;
        }
    }
    // puts("}");

    puts("YOU GOT IT!");

    return 0;
}